""" process_duty_csv.py

Processes the end of duty CSV files generated by duty_csv, downloading them
to locations defined in the CSV
"""
import subprocess
import os
import datetime
from ast import literal_eval
import tkinter as tk
from tkinter import filedialog
import pandas as pd
import config
from logger import Logger
import re


class ProcessCSV:
    """"""

    def __init__(self):
        """"""
        self.csv_path = filedialog.askopenfilename(
            initialdir=config.CSV_FOLDER,
            title="Select file",
            filetypes=(("CSV files", "*.csv"), ("all files", "*.*")),
        )
        self.csv_name = self.csv_path.split("\\")[-1]
        self.archive_csv_path = f"{config.ARCHIVE_FOLDER}{self.csv_name}"
        self.timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.logfile_path = (
            f"{self.csv_path.split('.duty_')[0]}."
            f"process_duty_{self.timestamp}.log"
        )
        self.archive_logfile_path = (
            f"{config.ARCHIVE_FOLDER}%s",
            self.logfile_path.split("\\")[-1],
        )
        self.logger = Logger(self.logfile_path).logger
        self.logger.info("Running duty_csv %s", git_tag())
        # Read in dataframe with GSTT_dir column as dtype list, then explode
        # so that each list item (directory destination) has its own row
        self.dataframe = (
            pd.read_csv(self.csv_path, converters={"GSTT_dir": literal_eval})
            .set_index(["Name", "Folder", "Type", "Url"])
            .GSTT_dir.apply(pd.Series)
            .stack()
            .reset_index(level=0)
            .rename(columns={0: "GSTT_dir"})
            .reset_index()
        )
        self.run_name = self.get_runfolder_dir("Please input the run name")
        self.command_list = self.create_commands()
        self.failure_list = self.download_data()
        # TODO may need to add a command to create the output dir
        self.archive_files()

    def get_runfolder_dir(self, label):
        """
        Process WES Runs
        """
        # Check if string conversion is in filepaths
        if self.dataframe["GSTT_dir"].str.contains("%s").any():
            run_name = self.collect_tkinter_var(label)
        else:
            run_name = False
        return run_name

    def collect_tkinter_var(self, label):
        """"""
        master = tk.Tk()
        entry = GetTkinterEntry(master, label)
        master.mainloop()
        return entry.entry_contents

    def create_commands(self):
        """
        Create download commands and add to dataframe as 'command' column
        """
        # Generate download commands
        command_list = (
            "Start-BitsTransfer -Source "
            + self.dataframe["Url"]
            + " -Destination "
            + self.dataframe["GSTT_dir"] % self.run_name
        ).tolist()
        # Generate unzip commands
        # Find CSV rows with zip files
        zip_files = self.dataframe["Url"].str.split(
            re.compile("https:\/\/.+\/"), expand=True
        )[1]
        # Generate unzip commands
        unzip_cmds = (
            "Expand-Archive -LiteralPath "
            + self.dataframe["GSTT_dir"] % self.run_name
            + zip_files
            + " -DestinationPath "
            + self.dataframe["GSTT_dir"] % self.run_name
        )
        command_list.extend(unzip_cmds)

        return command_list

    def download_data(self):
        """
        Downloads data by running each command in the dataframe using
        subprocesses
        """
        failure_list = []
        for command in self.command_list:
            if not self.run_subprocess(command):
                failure_list.append(command)
        return failure_list

    def run_subprocess(self, command):
        """
        Execute command using subprocess.Popen() and communicate output

            :param command (str):               Command string
            :return (stdout,stderr) (tuple):    Standard out and standard
        """
        try:
            out, err = subprocess.Popen(
                [command],
                stderr=subprocess.PIPE,
                stdout=subprocess.PIPE,
                shell=True,
                executable="powershell.exe",
            ).communicate()
            self.logger.info(out)
            self.logger.info(err)
            return True
        except subprocess.CalledProcessError as error:
            self.logger.error(
                "Command %s returned error (code %s): %s",
                error.cmd,
                error.returncode,
                error.output,
            )

    def archive_files(self):
        """
        Move the CSV file and logfile to the archive folder
        """
        if self.failure_list:
            self.logger.error(
                "The following commands did not execute successfully: %s",
                self.failure_list,
            )
        else:
            self.logger.info("All files downloaded successfully")
            os.rename(self.csv_path, self.archive_csv_path)
            os.rename(self.logfile_path, self.archive_logfile_path)


def git_tag():
    """Obtain git tag from current commit
    :return stdout (str):   String containing stdout,
                            with newline characters removed
    """
    filepath = os.path.dirname(os.path.realpath(__file__))
    cmd = f"git -C {filepath} describe --tags"

    proc = subprocess.Popen(
        [cmd], stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=True
    )
    out, _ = proc.communicate()
    return out.rstrip().decode("utf-8")


class GetTkinterEntry:
    """"""

    def __init__(self, master, label):
        self.master = master
        self.label = label
        self.entry_contents = None
        # Label for input using widget Label
        self.label = tk.Label(
            master, text=self.label, font=("calibre", 10, "bold")
        )
        self.label.grid(row=0, column=0)
        # Entry for input using widget Entry
        self.entry = tk.Entry(master, width=35, font=("calibre", 10, "normal"))
        self.entry.grid(row=0, column=1)

        self.entry.focus_set()

        tk.Button(master, text="Submit", width=10, command=self.callback).grid(
            row=10, column=0
        )

    def callback(self):
        """
        Get the contents of the Entry and exit
        """
        self.entry_contents = self.entry.get()
        self.master.quit()


if __name__ == "__main__":
    ProcessCSV()
